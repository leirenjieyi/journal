## 进程优先级

Linux对普通进程采用的是完全公平调度算法（CFS）

* Linux的进程调度并未使用直接均分时间片的方式，而是对优先级进行了改进，采用了两种不同的优先级范围，一种是nice值，范围是-20到+19，越大的nice值意味着更低的优先级，低nice值的进程会获得更多的处理器时间（按比例获得），第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围是从0到99，与nice值意义相反，越高的实时优先级数值意味着进程优先级越高，任何实时进程的优先级都高于普通进程
        PS：nice值还会不断对old优先级进行更改，当然也可以设置nice的值，nice值给负值必须要用root
    
* nice值不是优先级，但会影响优先级 PRI(new)=PRI(old)+nice
   
* 时间片过长会导致人机交互欠佳，而时间片过短会导致大量的处理器时间浪费在进程的切换上，而且I/O消耗型进程和处理器消耗型进程之间的处理器时间的不公平之处也显现出来了
    
* CFS并没有直接分配时间片到进程，而是将处理器的使用比划分给了进程，这个比例还会受到nice值的影响
    
* CFS的做法是允许每个进程运行一段时间，循环轮转，选择运行最少的进程作为写一个运行进程，所以根据nice值的含义-占用处理器的百分比，来根据系统中全部可运行进程总数来根据所占比例的“时间片”运行
    
* linux设计总是想分配给N个进程每个进程同样多的处理器运行时间，当N趋于无穷大的时候，按理说是可以分配给无限小的时间周期，但是这么做会很糟糕，我们也无法分配无限小的时间周期，虽然越小的时间周期可以带来更好的交互性，但还是带来不可接受的切换消耗，所以引入了一个目标延迟，来模拟无限小调度周期的近似值，现在假设目标延迟就是20ms，用它除以所有当前可以运行的进程数目就可以得到每个进程获得的时间片长度，当进程数无限大时候，每个进程分配的时间就趋于无限小，很好，进程切换又爆炸了，那么如果把最小值设为为1ms呢，进程数目再多我也保证每个进程在被强占之前获得1ms的运行时间，那么这个1ms就被称为最小粒度

__然而最后影响CFS调度器调度进程的并不是优先级的nice值，因为CFS说了，我要让每个进程获得的处理器时间都是一样的（虽然不可能），所以有一个vruntime的值表示进程运行的虚拟时间（就是在处理器上跑的时间累加和），这个vruntime值越小，说明该进程应该被优先执行（或者获得更多的处理器时间片），因为他饿了。。。__

一次调度间隔的虚拟运行时间=实际运行时间*（NICE_0_LOAD/权重）这就是nice值和vruntime之间的关系，其中，NICE_0_LOAD是nice为0时的权重

当nice值为0证明虚拟运行时间=实际运行时间