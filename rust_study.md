# 所有权(ownership)与作用域
所有权和作用域是rust内存管理的基础，也就是rust中所谓的 所有权系统；\
<b>所有权规则</b> 
1. 每一个值都被它的 所有者（owner）变量拥有。
2. 值在任意时刻只能被一个所有者拥有。
3. 当所有者离开作用域，这个值将被丢弃。

> 变量的所有权总是遵循相同的模式：将值赋值给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。

> <b>可变引用有一个很大的限制：在特定作用域中的特定数据有且只有一个可变引用</b>

<b>引用的规则</b> \
简要的概括一下对引用的讨论：在任意给定时间，只能 拥有如下中的一个：
1. 一个可变引用。
2. 任意数量的不可变引用。
* 引用必须总是有效的。

# 字符串的字面值

```rust
let s = "Hello, world!";
```
这里 s 的类型是 &str：它是一个指向二进制程序特定位置的 slice。这也就是为什么字符串字面值是不可变的；&str 是一个不可变引用。


# 模块文件系统的规则
与文件系统相关的模块规则总结如下：\
* 如果一个叫做 foo 的模块没有子模块，应该将 foo 的声明放入叫做 foo.rs 的文件中。
* 如果一个叫做 foo 的模块有子模块，应该将 foo 的声明放入叫做 foo/mod.rs 的文件中。\
这些规则适用于递归（嵌套），所以如果 foo 模块有一个子模块 bar 而 bar 没有子模块，则 src 目录中应该有如下文件：\
├── foo \
│   ├── bar.rs (contains the declarations in `foo::bar`) \
│   └── mod.rs (contains the declarations in `foo`, including `mod bar`) \
模块自身则应该使用 mod 关键字定义于父模块的文件中。

# 生命周期
生命周期是为了防止发生悬垂指针，即当引用的作用域大于被引用的作用域时就会出现悬垂指针，Rust中采用borrow checker来进行引用作用域的检查。当编译器不能推断出一个引用的作用域时，就需要人为为引用标记一个作用域。\
* 个人理解：这个生命周期泛型参数的主要是为返回值时引用类型的方法所使用，当有多个引用类型的输入参数时，引用类型的返回值的生命周期需要和哪个输入的引用参数的生命周期相一致。