# Docker中的数据管理
可以在容器的可写层中存储数据，但也有一些缺点：
* 当容器不再运行时，数据不会持久，如果另一个进程需要数据，则很难将数据从容器中取出。
* 容器的可写层紧密耦合到正在运行容器的主机上。你不能轻易地把数据移到其他地方。
* 写入容器的可写层需要存储驱动程序来管理文件系统。存储驱动程序使用Linux内核提供联合文件系统。与直接写入主机文件系统的数据卷相比，这种额外的抽象降低了性能。

Docker提供了从Docker主机将数据装入容器的三种不同方法：卷、绑定挂载或tmpfs卷。当无法确定时，卷几乎总是正确的选择。继续阅读有关将数据装入容器的每个机制的更多信息。

## 选择正确的挂载类型
无论您选择使用哪种类型的挂载，容器中的数据看起来都是一样的。它被公开为容器文件系统中的目录或单个文件。无论您选择使用哪种类型的挂载，容器中的数据看起来都是一样的。它被公开为容器文件系统中的目录或单个文件。

一个简单的方法来抽象出卷、绑定挂载、tmpfs卷之间的区别，就是思考一下他们在Docker主机上的存活位置.

<img src=img/docker_visualize.bmp />

* 卷存储在由Docker管理的主机文件系统的一部分中(/var/lib/docker/卷/在Linux上)。非Docker进程不应该修改文件系统的这一部分。卷是在Docker中持久化数据的最佳方法。
* 绑定挂载可以存储在主机系统的任何地方。它们甚至可能是重要的系统文件或目录。在Docker主机或Docker容器上的非Docker进程可以随时修改它们。
* tmpfs存储在主机系统的内存中，并没有写入到主机系统的文件系统。

## 挂载类型的更多细节
**Volumes:** 由Docker创建和管理。可以使用 ```docker volume create ``` 命令显式创建卷，也可以在容器或服务创建期间创建卷。

当你创建一个卷，它是存储在docker主机目录。当您将卷装入容器时，此目录就是装入容器中的目录。这是类似于绑定挂载的工作方式，除了卷是由docker管理以及从主机的核心功能分离。

给定的卷可以同时安装到多个容器中。当没有正在运行的容器使用卷时，Docker仍然可以使用卷，并且不会自动删除卷。您可以使用```docker volume prune ```命令删除未使用的卷。

当您挂载卷时，它可能是命名的或匿名的。当匿名卷第一次装入容器时，它们不会被指定名称，因此Docker给出了一个随机名称，保证它们在给定的Docker主机中是唯一的。除了名称之外，命名卷和匿名卷的行为方式是相同的。

卷还支持 *volume drivers* 的使用，它允许您将数据存储在远程主机或云提供商上，以及其他可能性。

**Bind mounts:** 这种方式应用于早期的Docker上。与卷相比，绑定挂载的功能有限。使用绑定挂载时，主机上的文件或目录将被装入容器中。文件或目录由主机上的完整路径引用。文件或目录不需要已经存在于Docker主机上。如果还不存在，则按需创建。绑定挂载具有很高的性能，但它们依赖于主机的文件系统，该文件系统具有特定的可用目录结构。如果您正在开发新的Docker应用程序，请考虑使用命名卷。不能使用Docker CLI 命令直接管理*bind mounts*。

<font color=red>
    Warning:使用绑定挂载的一个副作用是，您可以通过容器中运行的进程更改主机文件系统，包括创建、修改或删除重要的系统文件或目录。这是一种强大的能力，可以产生安全影响，包括影响主机系统上的非Docker进程。
</font>

**tmpfs mounts:** tmpfs挂载不会持久化到磁盘上，无论是在Docker主机上还是在容器中。它可以由容器在容器的生存期内用于存储非持久状态或敏感信息。例如，在内部，集群服务使用tmpfs mounts将保密数据挂载到服务的容器中。

绑定挂载和卷都可以使用-v或--volume 标志挂载到容器中，但每个容器的语法略有不同。对于tmpfs挂载，可以使用--tmpfs标志。但是，在Docker 17.06及更高版本中，我们建议对容器和服务使用--mount标志，用于绑定挂载、卷或tmpfs挂载，因为语法更加清楚。

## 何时用volume
卷是在Docker容器和服务中持久化数据的首选方法。卷的一些用例包括：
* 在多个正在运行的容器之间共享数据。如果您没有显式地创建它，则在第一次将卷挂载到容器中时就会创建卷。当该容器停止或被移除时，卷仍然存在。多个容器可以同时装入相同的卷，既可以读写，也可以只读。只有在显式删除卷时才会删除它们。
* 当不能保证Docker主机具有给定的目录或文件结构时。卷帮助您将Docker主机的配置与容器运行时分离开来。
* 当你想将容器的数据保存到远程主机或云端时，而不仅仅是本地存储。
* 当您需要备份、还原或将数据从一个Docker主机迁移到另一个Docker主机时，卷是一个更好的选择。您可以停止正在占用卷的容器，然后备份卷的目录(例如/var/lib/docker/volumes/<volk-name>)。

## 何时用bind mounts
通常，您应该在可能的情况下使用卷。绑定挂载适用于以下类型的用例：
* 将配置文件从主机共享到容器。这就是Docker默认情况下通过将/etc/resolv.conf从主机安装到每个容器来向容器提供DNS解析的方式。
* 在Docker主机上的开发环境和容器之间共享源代码或构建构件。例如，您可以将一个Maven target/ 目录挂载到容器中，并且每次在Docker主机上构建Maven项目时，容器都可以访问重建的工件。

    如果您以这种方式使用Docker进行开发，那么在生产的Dockerfile里应直接将可生产的工件复制到映像中，而不是依赖绑定挂载。
* 当保证Docker主机的文件或目录结构与容器要求的绑定挂载一致时。

## 何时用 tmpfs mounts
tmpfs mounts 最好用于不希望数据在主机上或容器中持久化的情况。这可能是出于安全原因，或者是为了在应用程序需要编写大量非持久状态数据时保护容器的性能。

## 使用绑定挂载或卷的提示
如果使用绑定挂载或卷，请记住以下几点：
* 如果你将一个空卷挂载到一个容器的目录，且这个目录存在文件或子目录，则这些文件或目录将传播(复制)到卷中。类似地，如果启动容器并指定不存在的卷，则会为您创建一个空卷。这是一种预先填充另一个容器所需数据的好方法。
* 如果您将绑定挂载或非空卷挂载到容器中的非空目录中，非空目录中的文件或目录就会被挂载所遮挡，就像您将文件保存到Linux主机上的/mnt中，然后将USB驱动器挂载到/mnt中一样。在卸载USB驱动器之前，/mnt的内容将被USB驱动器的内容模糊。被遮挡的文件不会被不移除或更改，但在绑定挂载或卷挂载时无法访问。

# 使用 volumes
卷是持久化由Docker容器生成和使用的数据的首选机制。绑定挂载依赖于主机的目录结构，卷则完全由Docker管理。与绑定挂载相比，卷有几个优点：

* 卷比绑定挂载更容易备份或迁移。
* 可以使用DockerCLI命令或DockerAPI管理卷。
* 卷在Linux和Windows容器上都可以工作。
* 卷可以更安全地在多个容器之间共享。
* 卷驱动程序允许您在远程主机或云提供程序上存储卷、加密卷的内容或添加其他功能。
* 新卷的内容可以由容器预先填充.

此外，卷通常比在容器的可写层中持久化数据更好，因为使用卷不会增加使用卷的容器的大小，而且卷的内容存在于给定容器的生命周期之外。
<img src=./img/docker_volumes.bmp />

如果您的容器生成非持久状态数据，请考虑使用tmpfs挂载来避免将数据永久存储在任何地方，并避免写入容器的可写层来提高容器的性能。

卷使用*rprivate* 绑定扩展，而绑定扩展对于卷是不可配置的。

## 选择 -v 还是 --mount 
最初，-v或--volume标志用于独立的容器，而--mount标志用于群集服务。但是，从Docker 17.06开始，您也可以使用--mount于独立的容器。一般来说，--mount更明确和详细。最大的区别是-v语法将所有选项组合在一个字段中，而--mount语法将它们分开。下面是每个标志语法的比较。

    提示：新用户应该使用--mount语法。经验丰富的用户可能更熟悉-v或--volume语法，但鼓励使用--mount，因为研究表明它更容易使用.
如果需要指定卷驱动程序选项，则必须使用--mount。

* -v or --volume 由三个字段组成，用冒号字符(:)分隔。字段必须按正确的顺序排列，并且每个字段的含义并不是很明显的。
    * 在命名卷的情况下，第一个字段是卷的名称，在给定的主机上是唯一的。对于匿名卷，省略第一个字段。
    * 第二个字段是将文件或目录挂载在容器中的路径。
    * 第三个字段是可选的，是一个逗号分隔的选项列表，如 *or* 。下面讨论这些选项。

* --mount 由多个键值对组成，以逗号分隔，每个键由<key>=<value>元组组成。mount语法比-v或--volume更冗长，但键的顺序并不重要，而且标志的值更容易理解。
    * type 挂载的类型，可以是bind、volume或tmpfs。本主题讨volume，因此类型总是volume。
    * source 挂载的源头。对于命名卷，这是卷的名称。对于匿名卷，省略此字段。可以指定为source或src。
    * destination 在容器中的挂载点。可以指定为destination、dst或target。
    * readonly 如果存在只读选项，则导致绑定挂载以只读形式安装到容器中。
    * volume-opt 选项可以多次指定，它接收key-value对作为选项的名称和值。

与bind mounts不同，volume的所有选项都可用于--mount和-v标志。当volume与service一起使用时，只支持--mount。

## 创建和管理volumes
与bind mounts不同，您可以在任何容器的作用域之外创建和管理卷。

**创建 volume**
```
wayne@ubuntu1604:~$ docker volume create my-vol
my-vol
```

**列举 volumes**
```
wayne@ubuntu1604:~$ docker volume ls
DRIVER              VOLUME NAME
local               my-vol
```
**查看 volume**
```
wayne@ubuntu1604:~$ docker volume inspect my-vol
[
    {
        "CreatedAt": "2018-02-26T15:19:34+08:00",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/my-vol/_data",
        "Name": "my-vol",
        "Options": {},
        "Scope": "local"
    }
]
```

**删除 volume**
```
wayne@ubuntu1604:~$ docker volume rm my-vol
my-vol
```

## 启动一个带有 volume的container
如果您使用尚不存在的卷启动容器，Docker将为您创建卷。下面的示例将myvol2卷挂载到容器中的/app/中。

```
$ docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
```

使用 docker inspect devtest 以验证卷是否已创建并正确安装。寻找Mounts 节：